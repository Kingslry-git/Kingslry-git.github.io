{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"相册","text":"","link":"/photos/index.html"},{"title":"","text":"关于本人ヾ(≧▽≦*)o 1234性别：男爱好：乒乓球、羽毛球、电影兴趣：balabala~感兴趣的研究方向：NLP、DATAMining","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"gallery1","text":"","link":"/2022/06/03/gallery1/"},{"title":"Today","text":"黑色周六1.今天只求两门考试顺利90+ 2.不要压抑自己( •̀ ω •́ )✧ 3.还要准备很多材料呢！（虽然老师也不会回复你） 4.要读论文和准备笔试还有CSP认证 5.从下周开始每天向blog上登刷题笔记捏！","link":"/2022/05/28/Today/"},{"title":"myProblemlist","text":"acwing.1671-三角形题目描述： Farmer John 想要给他的奶牛们建造一个三角形牧场。 有 NN 个栅栏柱子分别位于农场的二维平面上不同的点 (X1,Y1)…(XN,YN)(X1,Y1)…(XN,YN)。 他可以选择其中三个点组成三角形牧场，只要三角形有一条边与 xx 轴平行，且有另一条边与 yy 轴平行。 Farmer John 可以围成的牧场的最大面积是多少？ 保证存在至少一个合法的三角形牧场。 输入格式输入的第一行包含整数 NN。 以下 NN 行每行包含两个整数 XiXi 和 YiYi，均在范围 −104…104−104…104 之内，描述一个栅栏柱子的位置。 输出格式由于面积不一定为整数，输出栅栏柱子可以围成的合法三角形的最大面积的两倍。 数据范围3≤N≤1003≤N≤100 输入样例：1234540 00 11 01 2 输出样例：12 样例解释位于点 (0,0)、(1,0)(0,0)、(1,0) 和 (1,2)(1,2) 的木桩组成了一个面积为 11 的三角形。所以，答案为 2⋅1=22⋅1=2。 只有一个其他的三角形，面积为 0.50.5。 1234567891011121314151617181920212223242526//暴力枚举#include&lt;bits/stdc++.h&gt;#define x first#define y secondusing namespace std;const int N = 110;typedef pair&lt;int, int&gt; PII;PII p[N];int n;int res;int main(){ cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++) cin &gt;&gt; p[i].x &gt;&gt; p[i].y; for(int i = 0; i &lt; n; i ++) for(int j = 0;j &lt; n; j ++) for(int k = 0; k &lt; n; k ++) if(i != j &amp;&amp; j != k &amp;&amp; i != k) if(p[i].x == p[j].x &amp;&amp; p[j].y == p[k].y) res = max(res,abs(p[i].y - p[j].y) * abs(p[j].x - p[k].x)); cout &lt;&lt; res &lt;&lt; endl; return 0;}","link":"/2022/05/25/myProblemlist/"},{"title":"nlpLearning","text":"自然语言处理学习笔记","link":"/2022/06/07/nlpLearning/"},{"title":"tex_test","text":"$$ \\hat{x}_{k}=\\hat{x}_{k}^{-}+K_{t}\\left(y_{k}\\right) $$","link":"/2022/06/03/tex-test/"},{"title":"toDoList","text":"6.3 6.4 6.5 数理统计 nlp-车万翔 CSP","link":"/2022/06/03/toDoList/"},{"title":"动态规划-二进制+状态压缩","text":"动态规划：状态表示 + 状态计算状态压缩：使用整数来表示状态 二进制数字例题：acwing91 1.状态表示：$f[i,j]$ 所有从0到j，走过的所有点是i的所有路径，i为2进制数，0-1表示是否经过，表示状态$S$。 2.属性是求得$min$值 3.状态分割-状态计算， 从倒数第二个点的状态开始分割，[0,1…n -1],倒数第二个点为k, 0-&gt;k,k-&gt;j,k-&gt;j固定，求0-&gt;k的最小表示为$f[i-[j],k]$ 即得到$Min(f[i-[j],k] + a[k,j])$ 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 20, M = 1 &lt;&lt; N;int f[M][N], w[N][N];int n;int main(){ cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++) for(int j = 0;j &lt; n;j ++) cin &gt;&gt; w[i][j]; //初始化先假设未走通道路为无穷，待更新 memset(f,0x3f,sizeof f); f[1][0] = 0; for(int i = 0; i &lt; 1 &lt;&lt; n; i ++) for(int j = 0; j &lt; n; j ++) //此时状态要满足 if(i &gt;&gt; j &amp;&amp; 1) { for(int k = 0; k &lt; n;k ++) { if(i - (1 &lt;&lt; j) &gt;&gt; k &amp; 1) { f[i][j] = min(f[i][j],f[i - (1 &lt;&lt; j)][k] + w[k][j]); //cout &lt;&lt; f[i][j] &lt;&lt; endl; } } } cout &lt;&lt; f[(1 &lt;&lt; n) - 1][n - 1] &lt;&lt; endl;//注意运算优先级 return 0;} 树形dp例题：acwing285 建立树形结构，从根节点递归求解 分为$f[u,1]/f[u,0]$两部分求max 1.状态表示$f[u,0],$从所有以$u$为根的子树中选择，不选择$u$的集合；$f[u,1]$所有从以u为根的子树中选择，并选择$u$的集合 。 2.集合属性$Max$ 3.状态转移如上图 4.前向星建立树 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 6010;int n;int h[N], e[N], ne[N], idx;int happy[N];int f[N][2];bool has_father[N];void add(int a, int b){ e[idx] = b, ne[idx] = h[a], h[a] = idx ++;}void dfs(int u){ f[u][1] = happy[u]; for(int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; dfs(j); f[u][0] += max(f[j][0], f[j][1]); f[u][1] += f[j][0]; }}int main(){ cin &gt;&gt; n; for(int i = 1; i &lt;= n ; i ++) scanf(&quot;%d&quot;,&amp;happy[i]); memset(h,-1,sizeof h); for(int i = 1; i &lt;= n - 1;i ++) { int a, b; cin &gt;&gt; a &gt;&gt; b; has_father[a] = 1; add(b, a); } int root = 1; while(has_father[root]) root ++; //找到根节点并且从根节点开始 dfs(root); cout &lt;&lt; max(f[root][0],f[root][1]) &lt;&lt; endl; return 0;} 记忆化搜索acwing901 遍历过程不可存在环，否则状态转移无法结束 和bfs思路很像 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 310;int h[N][N], f[N][N];int n, m;int dx[4] = {1, -1, 0, 0}, dy[4] = {0, 0, -1, 1};int dp(int x, int y){ int &amp;v = f[x][y]; //此处的v引用很关键，保留了搜索过程中的最大状态，对f[][]完成修改，不重复计算 //如果使用dfs每个x,y开始都会重复搜索最大的路径 时间复杂度大 if(v != -1) return v; v = 1; for(int i = 0; i &lt; 4; i ++) { int a = x + dx[i], b = y + dy[i]; if(a &gt;= 1 &amp;&amp; a &lt;= n &amp;&amp; b &gt;= 1 &amp;&amp; b &lt;= m &amp;&amp; h[x][y] &gt; h[a][b]) v = max(v, dp(a,b) + 1); } return v;}int main(){ cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++) for(int j = 1; j &lt;= m;j ++) scanf(&quot;%d&quot;,&amp;h[i][j]); memset(f, -1, sizeof f); int res = 0; for(int i = 1;i &lt;= n;i ++) for(int j = 1; j &lt;= m; j ++) { res = max(res, dp(i, j)); //cout &lt;&lt; dp(i, j) &lt;&lt; endl; } cout &lt;&lt; res &lt;&lt; endl; return 0;}","link":"/2022/06/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"数学知识-算法","text":"一点简单数学知识[TOC] 1.组合数$C_a^b=\\frac{a!}{b!(a-b)!}$ $C_a^b=C_{a-1}^b+C_{a-1}^{b-1}$ 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 2010, mod = 1e9 + 7;int c[N][N];void init(){ for(int i = 0; i &lt; N; i ++) for(int j = 0;j &lt;= i;j ++) if(!j) c[i][j] = 1; else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;}int main(){ inti(); int n; cin &gt;&gt; n; while(n --) { int a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; c[a][b] &lt;&lt; endl; } return 0;} 2.快速幂","link":"/2022/06/05/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86-%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"校园风景","slug":"校园风景","link":"/tags/%E6%A0%A1%E5%9B%AD%E9%A3%8E%E6%99%AF/"},{"name":"碎嘴","slug":"碎嘴","link":"/tags/%E7%A2%8E%E5%98%B4/"},{"name":"NLP","slug":"NLP","link":"/tags/NLP/"},{"name":"学习日记","slug":"学习日记","link":"/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"学习","slug":"学习","link":"/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"tex","slug":"tex","link":"/categories/tex/"}]}