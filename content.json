{"pages":[{"title":"","text":"关于本人ヾ(≧▽≦*)o 1234性别：男爱好：乒乓球、羽毛球、电影兴趣：balabala~感兴趣的研究方向：NLP、DATAMining","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"相册","text":"","link":"/photos/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Today","text":"黑色周六1.今天只求两门考试顺利90+ 2.不要压抑自己( •̀ ω •́ )✧ 3.还要准备很多材料呢！（虽然老师也不会回复你） 4.要读论文和准备笔试还有CSP认证 5.从下周开始每天向blog上登刷题笔记捏！","link":"/2022/05/28/Today/"},{"title":"myProblemlist","text":"acwing.1671-三角形题目描述： Farmer John 想要给他的奶牛们建造一个三角形牧场。 有 NN 个栅栏柱子分别位于农场的二维平面上不同的点 (X1,Y1)…(XN,YN)(X1,Y1)…(XN,YN)。 他可以选择其中三个点组成三角形牧场，只要三角形有一条边与 xx 轴平行，且有另一条边与 yy 轴平行。 Farmer John 可以围成的牧场的最大面积是多少？ 保证存在至少一个合法的三角形牧场。 输入格式输入的第一行包含整数 NN。 以下 NN 行每行包含两个整数 XiXi 和 YiYi，均在范围 −104…104−104…104 之内，描述一个栅栏柱子的位置。 输出格式由于面积不一定为整数，输出栅栏柱子可以围成的合法三角形的最大面积的两倍。 数据范围3≤N≤1003≤N≤100 输入样例：1234540 00 11 01 2 输出样例：12 样例解释位于点 (0,0)、(1,0)(0,0)、(1,0) 和 (1,2)(1,2) 的木桩组成了一个面积为 11 的三角形。所以，答案为 2⋅1=22⋅1=2。 只有一个其他的三角形，面积为 0.50.5。 1234567891011121314151617181920212223242526//暴力枚举#include&lt;bits/stdc++.h&gt;#define x first#define y secondusing namespace std;const int N = 110;typedef pair&lt;int, int&gt; PII;PII p[N];int n;int res;int main(){ cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++) cin &gt;&gt; p[i].x &gt;&gt; p[i].y; for(int i = 0; i &lt; n; i ++) for(int j = 0;j &lt; n; j ++) for(int k = 0; k &lt; n; k ++) if(i != j &amp;&amp; j != k &amp;&amp; i != k) if(p[i].x == p[j].x &amp;&amp; p[j].y == p[k].y) res = max(res,abs(p[i].y - p[j].y) * abs(p[j].x - p[k].x)); cout &lt;&lt; res &lt;&lt; endl; return 0;}","link":"/2022/05/25/myProblemlist/"},{"title":"gallery1","text":"","link":"/2022/06/03/gallery1/"},{"title":"tex_test","text":"$$ \\hat{x}_{k}=\\hat{x}_{k}^{-}+K_{t}\\left(y_{k}\\right) $$","link":"/2022/06/03/tex-test/"},{"title":"toDoList","text":"6.3 6.4 6.5 数理统计 nlp-车万翔 CSP","link":"/2022/06/03/toDoList/"},{"title":"动态规划-二进制+状态压缩","text":"动态规划：状态表示 + 状态计算例题：acwing91 1.状态表示：$f[i,j]$ 所有从0到j，走过的所有点是i的所有路径，i为2进制数，0-1表示是否经过，表示状态$S$。 2.属性是求得$min$值 3.状态分割-状态计算， 从倒数第二个点的状态开始分割，[0,1…n -1],倒数第二个点为k, 0-&gt;k,k-&gt;j,k-&gt;j固定，求0-&gt;k的最小表示为$f[i-[j],k]$ 即得到$Min(f[i-[j],k] + a[k,j])$ 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 20, M = 1 &lt;&lt; N;int f[M][N], w[N][N];int n;int main(){ cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++) for(int j = 0;j &lt; n;j ++) cin &gt;&gt; w[i][j]; //初始化先假设未走通道路为无穷，待更新 memset(f,0x3f,sizeof f); f[1][0] = 0; for(int i = 0; i &lt; 1 &lt;&lt; n; i ++) for(int j = 0; j &lt; n; j ++) //此时状态要满足 if(i &gt;&gt; j &amp;&amp; 1) { for(int k = 0; k &lt; n;k ++) { if(i - (1 &lt;&lt; j) &gt;&gt; k &amp; 1) { f[i][j] = min(f[i][j],f[i - (1 &lt;&lt; j)][k] + w[k][j]); //cout &lt;&lt; f[i][j] &lt;&lt; endl; } } } cout &lt;&lt; f[(1 &lt;&lt; n) - 1][n - 1] &lt;&lt; endl;//注意运算优先级 return 0;} 树形dp例题：acwing285 建立树形结构，从根节点递归求解 分为$f[u,1]/f[u,0]$两部分求max 1.状态表示$f[u,0],$从所有以$u$为根的子树中选择，不选择$u$的集合；$f[u,1]$所有从以u为根的子树中选择，并选择$u$的集合 。 2.集合属性$Max$ 3.状态转移$\\sum\\limits_{i=0}^n {f(i)}$","link":"/2022/06/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"碎嘴","slug":"碎嘴","link":"/tags/%E7%A2%8E%E5%98%B4/"},{"name":"校园风景","slug":"校园风景","link":"/tags/%E6%A0%A1%E5%9B%AD%E9%A3%8E%E6%99%AF/"},{"name":"学习日记","slug":"学习日记","link":"/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"tex","slug":"tex","link":"/categories/tex/"},{"name":"学习","slug":"学习","link":"/categories/%E5%AD%A6%E4%B9%A0/"}]}