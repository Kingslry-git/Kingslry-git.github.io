{"pages":[{"title":"关于我","text":"关于本人本人：男 昵称：咚咚 爱好：乒乓球、羽毛球、电影 感兴趣的方向：自然语言处理，数据挖掘 ​ 学不会的东西：算法，数学 天赋技能：摆烂 个人特点：间歇性热血，持续性无所事事 ​","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"相册","text":"21B的天空–before June 3rd 手机随拍","link":"/photos/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"ML-note","text":"懒狗看到哪里写到哪里吧","link":"/2022/06/07/ML-note/"},{"title":"408","text":"一、计算机网络1.计算机网络体系结构协议由语法、语义和同步三部分组成。 语法：规定数据格式 语义：规定所要完成的功能 同步：规定完成的条件、时序关系。 接口是相邻两层交换信息的节点，逻辑概念。 服务是指下层为紧邻的上层提供功能调用，垂直功能。 2.ISO/OSI &amp; TCP/IPOSI参考模型：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。其中，低三层称为通信子网，高三层为资源子网。 1.物理层：（规定了一些物理参数和电气特性） 为数据端设备透明地传输原始比特流。 2.数据链路层： 帧，将网络层传来的IP数据报组装成帧。 封装成帧、差错控制、流量控制、传输管理etc。 3.网络层：数据报 任务：把网络层数据单元从源地址传到目的端，包括路由选择、流量控制、拥塞控制、差错控制、网际互联etc。 4.传输层：tcp/udp 负责主机两个进程之间的通信，提供端到端的可靠传输服务，端到端的服务质量控制。 difference：数据链路层提供点到点，传输层是端到端。 5.会话层： 为表示层实体和用户建立同步 6.表示层： 不同机器编码、表示方式的变化层 7.应用层： 提供不同的网络应用要求，例如WWW、HTTP、FTP服务 tcp/ip：结构如图所示 3.物理层 4.数据链路层 二、数据库原理1.B树又称多路平衡查找树：提高磁盘查找效率 非叶节点： [n P0 K1 P1 K2 P2 ... Kn Pn]k表示为关键字、p表示为指针，Pi-1所指向的子树关键字均小于Ki，Pi所指向的子树的关键字均大于Ki 另：所有的叶节点都出现在同一层次上，并不带任何信息$$对于n个关键字，阶数为m，高度为h的B树有以下性质 \\log_m{(n+1)} \\leq h \\leq log_{[m/2]}((n+1)/2)+1$$B树的插入、删除： 插入： 1）定位 查找插入该关键字的位置，最底层非叶子节点 2）插入 插入后不会违反定义，插入后结点关键字个数在属于合法区间 删除：终端节点 ||非终端节点 1） 直接删除（不破坏定义） 2）借兄弟节点，并修改双亲节点 3）与兄弟节点合并 4） 删除非终端节点：1.先与终端节点替换再删除 2.先合并子树再执行删除 ​ 三、数据结构1.红黑树性质：1.结点是红/黑色 2.根节点为黑 3.所有叶子节点都是黑色 叶子为NIL节点 4.每个红色结点的子结点都是黑色（从每个叶子到根没有连续的红色结点） 5.从一任意结点其每个叶子的所有路径黑色结点数目相同 6.从根到叶子最长路径不多于最短的可能路径的两倍长 操作：","link":"/2022/06/28/408/"},{"title":"gallery1","text":"","link":"/2022/06/03/gallery1/"},{"title":"Today","text":"黑色周六1.今天只求两门考试顺利90+ 2.不要压抑自己( •̀ ω •́ )✧ 3.还要准备很多材料呢！（虽然老师也不会回复你） 4.要读论文和准备笔试还有CSP认证 5.从下周开始每天向blog上登刷题笔记捏！","link":"/2022/05/28/Today/"},{"title":"myProblemlist","text":"acwing.1671-三角形题目描述： Farmer John 想要给他的奶牛们建造一个三角形牧场。 有 NN 个栅栏柱子分别位于农场的二维平面上不同的点 (X1,Y1)…(XN,YN)(X1,Y1)…(XN,YN)。 他可以选择其中三个点组成三角形牧场，只要三角形有一条边与 xx 轴平行，且有另一条边与 yy 轴平行。 Farmer John 可以围成的牧场的最大面积是多少？ 保证存在至少一个合法的三角形牧场。 输入格式输入的第一行包含整数 NN。 以下 NN 行每行包含两个整数 XiXi 和 YiYi，均在范围 −104…104−104…104 之内，描述一个栅栏柱子的位置。 输出格式由于面积不一定为整数，输出栅栏柱子可以围成的合法三角形的最大面积的两倍。 数据范围3≤N≤1003≤N≤100 输入样例：1234540 00 11 01 2 输出样例：12 样例解释位于点 (0,0)、(1,0)(0,0)、(1,0) 和 (1,2)(1,2) 的木桩组成了一个面积为 11 的三角形。所以，答案为 2⋅1=22⋅1=2。 只有一个其他的三角形，面积为 0.50.5。 1234567891011121314151617181920212223242526//暴力枚举#include&lt;bits/stdc++.h&gt;#define x first#define y secondusing namespace std;const int N = 110;typedef pair&lt;int, int&gt; PII;PII p[N];int n;int res;int main(){ cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++) cin &gt;&gt; p[i].x &gt;&gt; p[i].y; for(int i = 0; i &lt; n; i ++) for(int j = 0;j &lt; n; j ++) for(int k = 0; k &lt; n; k ++) if(i != j &amp;&amp; j != k &amp;&amp; i != k) if(p[i].x == p[j].x &amp;&amp; p[j].y == p[k].y) res = max(res,abs(p[i].y - p[j].y) * abs(p[j].x - p[k].x)); cout &lt;&lt; res &lt;&lt; endl; return 0;}","link":"/2022/05/25/myProblemlist/"},{"title":"nlpLearning","text":"自然语言处理学习笔记","link":"/2022/06/07/nlpLearning/"},{"title":"动态规划-二进制+状态压缩","text":"动态规划：状态表示 + 状态计算状态压缩：使用整数来表示状态 二进制数字例题：acwing91 1.状态表示：$f[i,j]$ 所有从0到j，走过的所有点是i的所有路径，i为2进制数，0-1表示是否经过，表示状态$S$。 2.属性是求得$min$值 3.状态分割-状态计算， 从倒数第二个点的状态开始分割，[0,1…n -1],倒数第二个点为k, 0-&gt;k,k-&gt;j,k-&gt;j固定，求0-&gt;k的最小表示为$f[i-[j],k]$ 即得到$Min(f[i-[j],k] + a[k,j])$ 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 20, M = 1 &lt;&lt; N;int f[M][N], w[N][N];int n;int main(){ cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++) for(int j = 0;j &lt; n;j ++) cin &gt;&gt; w[i][j]; //初始化先假设未走通道路为无穷，待更新 memset(f,0x3f,sizeof f); f[1][0] = 0; for(int i = 0; i &lt; 1 &lt;&lt; n; i ++) for(int j = 0; j &lt; n; j ++) //此时状态要满足 if(i &gt;&gt; j &amp;&amp; 1) { for(int k = 0; k &lt; n;k ++) { if(i - (1 &lt;&lt; j) &gt;&gt; k &amp; 1) { f[i][j] = min(f[i][j],f[i - (1 &lt;&lt; j)][k] + w[k][j]); //cout &lt;&lt; f[i][j] &lt;&lt; endl; } } } cout &lt;&lt; f[(1 &lt;&lt; n) - 1][n - 1] &lt;&lt; endl;//注意运算优先级 return 0;} 树形dp例题：acwing285 建立树形结构，从根节点递归求解 分为$f[u,1]/f[u,0]$两部分求max 1.状态表示$f[u,0],$从所有以$u$为根的子树中选择，不选择$u$的集合；$f[u,1]$所有从以u为根的子树中选择，并选择$u$的集合 。 2.集合属性$Max$ 3.状态转移如上图 4.前向星建立树 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 6010;int n;int h[N], e[N], ne[N], idx;int happy[N];int f[N][2];bool has_father[N];void add(int a, int b){ e[idx] = b, ne[idx] = h[a], h[a] = idx ++;}void dfs(int u){ f[u][1] = happy[u]; for(int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; dfs(j); f[u][0] += max(f[j][0], f[j][1]); f[u][1] += f[j][0]; }}int main(){ cin &gt;&gt; n; for(int i = 1; i &lt;= n ; i ++) scanf(&quot;%d&quot;,&amp;happy[i]); memset(h,-1,sizeof h); for(int i = 1; i &lt;= n - 1;i ++) { int a, b; cin &gt;&gt; a &gt;&gt; b; has_father[a] = 1; add(b, a); } int root = 1; while(has_father[root]) root ++; //找到根节点并且从根节点开始 dfs(root); cout &lt;&lt; max(f[root][0],f[root][1]) &lt;&lt; endl; return 0;} 记忆化搜索acwing901 遍历过程不可存在环，否则状态转移无法结束 和bfs思路很像 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 310;int h[N][N], f[N][N];int n, m;int dx[4] = {1, -1, 0, 0}, dy[4] = {0, 0, -1, 1};int dp(int x, int y){ int &amp;v = f[x][y]; //此处的v引用很关键，保留了搜索过程中的最大状态，对f[][]完成修改，不重复计算 //如果使用dfs每个x,y开始都会重复搜索最大的路径 时间复杂度大 if(v != -1) return v; v = 1; for(int i = 0; i &lt; 4; i ++) { int a = x + dx[i], b = y + dy[i]; if(a &gt;= 1 &amp;&amp; a &lt;= n &amp;&amp; b &gt;= 1 &amp;&amp; b &lt;= m &amp;&amp; h[x][y] &gt; h[a][b]) v = max(v, dp(a,b) + 1); } return v;}int main(){ cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++) for(int j = 1; j &lt;= m;j ++) scanf(&quot;%d&quot;,&amp;h[i][j]); memset(f, -1, sizeof f); int res = 0; for(int i = 1;i &lt;= n;i ++) for(int j = 1; j &lt;= m; j ++) { res = max(res, dp(i, j)); //cout &lt;&lt; dp(i, j) &lt;&lt; endl; } cout &lt;&lt; res &lt;&lt; endl; return 0;}","link":"/2022/06/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"数学知识-算法","text":"一点简单数学知识1.组合数$C_a^b=\\frac{a!}{b!(a-b)!}$ $C_a^b=C_{a-1}^b+C_{a-1}^{b-1}$ 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 2010, mod = 1e9 + 7;int c[N][N];void init(){ for(int i = 0; i &lt; N; i ++) for(int j = 0;j &lt;= i;j ++) if(!j) c[i][j] = 1; else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;}int main(){ inti(); int n; cin &gt;&gt; n; while(n --) { int a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; c[a][b] &lt;&lt; endl; } return 0;} 2.快速幂","link":"/2022/06/05/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86-%E7%AE%97%E6%B3%95/"},{"title":"实习","text":"springboot1.整合了框架，无需编写大量配置文件，习惯优于配置。 学习目录 Spring SpringMVC Mybatis fastjson Mybatis分页 redis","link":"/2022/07/06/%E5%AE%9E%E4%B9%A0/"},{"title":"西瓜书读书笔记","text":"chapter4-决策树4.1基本概念​ 决策树是一种常见的机器学习分类方法，在分类任务为例，在若干轮决策过程后对样本进行分类，这是一种非常自然的思考过程，以树结构来进行决策、判定。如下图所示： ​ 其中，非叶节点为属性测试，叶节点为样本分类，决策树训练的目的是为了产生一一棵泛化能力强，对未见过样本分类能力强的决策树。 4.2划分选择4.2.1信息增益​ 我们现有的信息熵公式$Ent(D)=-\\sum_\\limits{k=1}^\\limits{|y|}p_klog_2{p_k}$，其中y定义为样本分类的种类。 ​ 对于信息增益的示意是：对某个离散属性$a$在样本集合$D$上进行划分，产生$V$个分支节点，我们可以算出在$a$下进行划分的样本$D^v$的信息熵，并且根据分支节点中所包含样本数的不同给分支节点赋予权重$|D^v|/|D|$，样本数越多分支结点影响权重越大，于是计算出“信息增益”:$$Gain(D,a)=Ent(D)-\\sum_\\limits{v=1}^\\limits{V}Ent{D^v} \\tag{4.2}$$​ 一般来说，信息增益越大，说明使用属性$a$来进行划分获得的纯度提升更大(purity)，也即为分类属性的区分度高。例如著名的ID3决策树学习算法就是以信息增益为准则划分属性。 ​ 值得注意的是决策树每层划分都要基于不同的分类节点重新计算信息增益。 4.2.2增益率​ 我们时常忽略样本编号这一属性，是因为该属性不具有泛化能力，无法对新样本提供有效预测。 ​ 实际上信息增益会具有某些属性的“偏好性”，为了减少这种影响，C4.5决策树算法采用增益率来选择最优划分属性。$$Gain_ratio(D,a)=\\frac{Gain(D,a)}{IV{a}}\\tag{4.3}$$其中$$IV(a)=-\\sum_\\limits{v=1}^\\limits{V}\\frac{|D^v|}{|D|}log_2\\frac{|D^v|}{|D|} \\tag{4.4}$$$IV(a)$称为$a$属性的固有值，属性a，可能取值数目越多，则$IV(a)$值会增大。增益率准则(未完待续)","link":"/2022/06/24/%E8%A5%BF%E7%93%9C%E4%B9%A6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ML&#x2F;DL","slug":"ML-DL","link":"/tags/ML-DL/"},{"name":"专业课","slug":"专业课","link":"/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"},{"name":"校园风景","slug":"校园风景","link":"/tags/%E6%A0%A1%E5%9B%AD%E9%A3%8E%E6%99%AF/"},{"name":"碎嘴","slug":"碎嘴","link":"/tags/%E7%A2%8E%E5%98%B4/"},{"name":"NLP","slug":"NLP","link":"/tags/NLP/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"开发","slug":"开发","link":"/tags/%E5%BC%80%E5%8F%91/"}],"categories":[{"name":"学习","slug":"学习","link":"/categories/%E5%AD%A6%E4%B9%A0/"}]}