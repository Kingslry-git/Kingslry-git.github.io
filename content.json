{"pages":[{"title":"关于我","text":"关于本人本人：男 昵称：咚咚 爱好：乒乓球、羽毛球、电影 感兴趣的方向：自然语言处理，数据挖掘 ​ 学不会的东西：算法，数学 天赋技能：摆烂 个人特点：间歇性热血，持续性无所事事 ​","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"相册","text":"21B的天空–before June 3rd 手机随拍","link":"/photos/index.html"}],"posts":[{"title":"Today","text":"黑色周六1.今天只求两门考试顺利90+ 2.不要压抑自己( •̀ ω •́ )✧ 3.还要准备很多材料呢！（虽然老师也不会回复你） 4.要读论文和准备笔试还有CSP认证 5.从下周开始每天向blog上登刷题笔记捏！","link":"/2022/05/28/Today/"},{"title":"myProblemlist","text":"acwing.1671-三角形题目描述： Farmer John 想要给他的奶牛们建造一个三角形牧场。 有 NN 个栅栏柱子分别位于农场的二维平面上不同的点 (X1,Y1)…(XN,YN)(X1,Y1)…(XN,YN)。 他可以选择其中三个点组成三角形牧场，只要三角形有一条边与 xx 轴平行，且有另一条边与 yy 轴平行。 Farmer John 可以围成的牧场的最大面积是多少？ 保证存在至少一个合法的三角形牧场。 输入格式输入的第一行包含整数 NN。 以下 NN 行每行包含两个整数 XiXi 和 YiYi，均在范围 −104…104−104…104 之内，描述一个栅栏柱子的位置。 输出格式由于面积不一定为整数，输出栅栏柱子可以围成的合法三角形的最大面积的两倍。 数据范围3≤N≤1003≤N≤100 输入样例：1234540 00 11 01 2 输出样例：12 样例解释位于点 (0,0)、(1,0)(0,0)、(1,0) 和 (1,2)(1,2) 的木桩组成了一个面积为 11 的三角形。所以，答案为 2⋅1=22⋅1=2。 只有一个其他的三角形，面积为 0.50.5。 1234567891011121314151617181920212223242526//暴力枚举#include&lt;bits/stdc++.h&gt;#define x first#define y secondusing namespace std;const int N = 110;typedef pair&lt;int, int&gt; PII;PII p[N];int n;int res;int main(){ cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++) cin &gt;&gt; p[i].x &gt;&gt; p[i].y; for(int i = 0; i &lt; n; i ++) for(int j = 0;j &lt; n; j ++) for(int k = 0; k &lt; n; k ++) if(i != j &amp;&amp; j != k &amp;&amp; i != k) if(p[i].x == p[j].x &amp;&amp; p[j].y == p[k].y) res = max(res,abs(p[i].y - p[j].y) * abs(p[j].x - p[k].x)); cout &lt;&lt; res &lt;&lt; endl; return 0;}","link":"/2022/05/25/myProblemlist/"},{"title":"gallery1","text":"","link":"/2022/06/03/gallery1/"},{"title":"ML-note","text":"懒狗看到哪里写到哪里吧","link":"/2022/06/07/ML-note/"},{"title":"nlpLearning","text":"自然语言处理学习笔记","link":"/2022/06/07/nlpLearning/"},{"title":"数学知识-算法","text":"一点简单数学知识1.组合数$C_a^b=\\frac{a!}{b!(a-b)!}$ $C_a^b=C_{a-1}^b+C_{a-1}^{b-1}$ 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 2010, mod = 1e9 + 7;int c[N][N];void init(){ for(int i = 0; i &lt; N; i ++) for(int j = 0;j &lt;= i;j ++) if(!j) c[i][j] = 1; else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;}int main(){ inti(); int n; cin &gt;&gt; n; while(n --) { int a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; c[a][b] &lt;&lt; endl; } return 0;} 2.快速幂","link":"/2022/06/05/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86-%E7%AE%97%E6%B3%95/"},{"title":"动态规划-二进制+状态压缩","text":"动态规划：状态表示 + 状态计算状态压缩：使用整数来表示状态 二进制数字例题：acwing91 1.状态表示：$f[i,j]$ 所有从0到j，走过的所有点是i的所有路径，i为2进制数，0-1表示是否经过，表示状态$S$。 2.属性是求得$min$值 3.状态分割-状态计算， 从倒数第二个点的状态开始分割，[0,1…n -1],倒数第二个点为k, 0-&gt;k,k-&gt;j,k-&gt;j固定，求0-&gt;k的最小表示为$f[i-[j],k]$ 即得到$Min(f[i-[j],k] + a[k,j])$ 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 20, M = 1 &lt;&lt; N;int f[M][N], w[N][N];int n;int main(){ cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++) for(int j = 0;j &lt; n;j ++) cin &gt;&gt; w[i][j]; //初始化先假设未走通道路为无穷，待更新 memset(f,0x3f,sizeof f); f[1][0] = 0; for(int i = 0; i &lt; 1 &lt;&lt; n; i ++) for(int j = 0; j &lt; n; j ++) //此时状态要满足 if(i &gt;&gt; j &amp;&amp; 1) { for(int k = 0; k &lt; n;k ++) { if(i - (1 &lt;&lt; j) &gt;&gt; k &amp; 1) { f[i][j] = min(f[i][j],f[i - (1 &lt;&lt; j)][k] + w[k][j]); //cout &lt;&lt; f[i][j] &lt;&lt; endl; } } } cout &lt;&lt; f[(1 &lt;&lt; n) - 1][n - 1] &lt;&lt; endl;//注意运算优先级 return 0;} 树形dp例题：acwing285 建立树形结构，从根节点递归求解 分为$f[u,1]/f[u,0]$两部分求max 1.状态表示$f[u,0],$从所有以$u$为根的子树中选择，不选择$u$的集合；$f[u,1]$所有从以u为根的子树中选择，并选择$u$的集合 。 2.集合属性$Max$ 3.状态转移如上图 4.前向星建立树 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 6010;int n;int h[N], e[N], ne[N], idx;int happy[N];int f[N][2];bool has_father[N];void add(int a, int b){ e[idx] = b, ne[idx] = h[a], h[a] = idx ++;}void dfs(int u){ f[u][1] = happy[u]; for(int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; dfs(j); f[u][0] += max(f[j][0], f[j][1]); f[u][1] += f[j][0]; }}int main(){ cin &gt;&gt; n; for(int i = 1; i &lt;= n ; i ++) scanf(&quot;%d&quot;,&amp;happy[i]); memset(h,-1,sizeof h); for(int i = 1; i &lt;= n - 1;i ++) { int a, b; cin &gt;&gt; a &gt;&gt; b; has_father[a] = 1; add(b, a); } int root = 1; while(has_father[root]) root ++; //找到根节点并且从根节点开始 dfs(root); cout &lt;&lt; max(f[root][0],f[root][1]) &lt;&lt; endl; return 0;} 记忆化搜索acwing901 遍历过程不可存在环，否则状态转移无法结束 和bfs思路很像 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 310;int h[N][N], f[N][N];int n, m;int dx[4] = {1, -1, 0, 0}, dy[4] = {0, 0, -1, 1};int dp(int x, int y){ int &amp;v = f[x][y]; //此处的v引用很关键，保留了搜索过程中的最大状态，对f[][]完成修改，不重复计算 //如果使用dfs每个x,y开始都会重复搜索最大的路径 时间复杂度大 if(v != -1) return v; v = 1; for(int i = 0; i &lt; 4; i ++) { int a = x + dx[i], b = y + dy[i]; if(a &gt;= 1 &amp;&amp; a &lt;= n &amp;&amp; b &gt;= 1 &amp;&amp; b &lt;= m &amp;&amp; h[x][y] &gt; h[a][b]) v = max(v, dp(a,b) + 1); } return v;}int main(){ cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++) for(int j = 1; j &lt;= m;j ++) scanf(&quot;%d&quot;,&amp;h[i][j]); memset(f, -1, sizeof f); int res = 0; for(int i = 1;i &lt;= n;i ++) for(int j = 1; j &lt;= m; j ++) { res = max(res, dp(i, j)); //cout &lt;&lt; dp(i, j) &lt;&lt; endl; } cout &lt;&lt; res &lt;&lt; endl; return 0;}","link":"/2022/06/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"西瓜书读书笔记","text":"chapter4-决策树4.1基本概念​ 决策树是一种常见的机器学习分类方法，在分类任务为例，在若干轮决策过程后对样本进行分类，这是一种非常自然的思考过程，以树结构来进行决策、判定。如下图所示： ​ 其中，非叶节点为属性测试，叶节点为样本分类，决策树训练的目的是为了产生一一棵泛化能力强，对未见过样本分类能力强的决策树。 4.2划分选择4.2.1信息增益​ 我们现有的信息熵公式$Ent(D)=-\\sum_\\limits{k=1}^\\limits{|y|}p_klog_2{p_k}$，其中y定义为样本分类的种类。 ​ 对于信息增益的示意是：对某个离散属性$a$在样本集合$D$上进行划分，产生$V$个分支节点，我们可以算出在$a$下进行划分的样本$D^v$的信息熵，并且根据分支节点中所包含样本数的不同给分支节点赋予权重$|D^v|/|D|$，样本数越多分支结点影响权重越大，于是计算出“信息增益”:$$Gain(D,a)=Ent(D)-\\sum_\\limits{v=1}^\\limits{V}Ent{D^v} \\tag{4.2}$$​ 一般来说，信息增益越大，说明使用属性$a$来进行划分获得的纯度提升更大(purity)，也即为分类属性的区分度高。例如著名的ID3决策树学习算法就是以信息增益为准则划分属性。 ​ 值得注意的是决策树每层划分都要基于不同的分类节点重新计算信息增益。 4.2.2增益率​ 我们时常忽略样本编号这一属性，是因为该属性不具有泛化能力，无法对新样本提供有效预测。 ​ 实际上信息增益会具有某些属性的“偏好性”，为了减少这种影响，C4.5决策树算法采用增益率来选择最优划分属性。$$Gain_ratio(D,a)=\\frac{Gain(D,a)}{IV{a}}\\tag{4.3}$$其中$$IV(a)=-\\sum_\\limits{v=1}^\\limits{V}\\frac{|D^v|}{|D|}log_2\\frac{|D^v|}{|D|} \\tag{4.4}$$$IV(a)$称为$a$属性的固有值，属性a，可能取值数目越多，则$IV(a)$值会增大。增益率准则(未完待续)","link":"/2022/06/24/%E8%A5%BF%E7%93%9C%E4%B9%A6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"碎嘴","slug":"碎嘴","link":"/tags/%E7%A2%8E%E5%98%B4/"},{"name":"校园风景","slug":"校园风景","link":"/tags/%E6%A0%A1%E5%9B%AD%E9%A3%8E%E6%99%AF/"},{"name":"ML&#x2F;DL","slug":"ML-DL","link":"/tags/ML-DL/"},{"name":"NLP","slug":"NLP","link":"/tags/NLP/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"学习","slug":"学习","link":"/categories/%E5%AD%A6%E4%B9%A0/"}]}